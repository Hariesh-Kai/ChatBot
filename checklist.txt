ğŸ”´ PHASE 1 â€” CHAT-BREAKING BUGS (DO FIRST)
âœ…ğŸ“ backend/state/abort_signals.py

â˜ Replace unsafe env parsing

_USE_REDIS = os.getenv("USE_ABORT_REDIS", "0").lower() in ("1", "true", "yes")


â˜ When Redis reports abort â†’ set in-memory event (cache it)

â˜ On job/session reset â†’ call _cleanup_session_event(session_id)

â˜ Ensure abort is reset before starting any new generation

âœ…ğŸ“ backend/state/job_state.py

â˜ On clear_job_for_session(session_id) â†’ call:

reset_abort_signal(session_id)


â˜ Prevent orphan jobs when same session creates new job:

if session_id in _SESSION_JOB_MAP:
    old_job = _SESSION_JOB_MAP[session_id]
    _JOB_STORE.pop(old_job, None)


â˜ Document or enforce single-worker requirement

â˜ (Optional) Add debug log on job transitions

ğŸ”´ PHASE 2 â€” EMPTY / MISSING RESPONSES
âœ… ğŸ“ backend/llm/generate.py

â˜ After final apply_response_policy(...) â†’ YIELD IT

yield apply_response_policy(draft, verbosity=style.verbosity)


â˜ Ensure at least one token is yielded in every path

â˜ Remove silent return after response policy

â˜ Ensure conversational intent routes to lite correctly

âœ… ğŸ“  backend/llm/answer_policy.py

â˜ Do NOT mark greetings as needs_clarification=True

â˜ Ensure verbosity="one_line" for greetings

âœ… ğŸ“  backend/llm/loader.py

â˜ After abort â†’ try short thread.join(timeout=0.2)

â˜ Ensure GGUF wrapper always yields normalized dict

ğŸ”´ PHASE 3 â€” RAG FAILURES & SQL ERRORS
âœ… ğŸ“  backend/rag/ingest.py

â˜ Replace ALL SQL references:

metadata -> cmetadata


â˜ Fix delete query:

WHERE cmetadata->>'document_id' = %s


â˜ Fix update query:

SET cmetadata = cmetadata || %s::jsonb


â˜ Ensure connection string normalization everywhere

âœ… ğŸ“  backend/rag/keyword_search.py

â˜ Replace wrong column name:

document â†’ page_content


â˜ Ensure metadata filter uses cmetadata

â˜ Limit keyword search results to â‰¤10

âœ… ğŸ“  backend/rag/confidence.py

â˜ Guard against empty similarity scores AFTER sanitization

â˜ Ensure confidence always âˆˆ [0,1]

ğŸŸ  PHASE 4 â€” MEMORY CONSISTENCY
âœ… ğŸ“  backend/memory/pg_memory.py

â˜ Make ensure_session + insert message atomic

â˜ Skip saving message if session aborted

â˜ Cap limit in get_chat_messages() (â‰¤200)

âœ… ğŸ“  backend/memory/redis_memory.py

â˜ Store topic text, not hash only

â˜ Wrap Redis calls in try/except with logs

â˜ Reset used chunks when topic changes

ğŸŸ  PHASE 5 â€” STORAGE & SECURITY
âœ… ğŸ“  backend/storage/minio_client.py

â˜ Remove default credentials âŒ
â˜ Fail fast if creds missing
â˜ Make secure configurable via env
â˜ Handle bucket creation race
â˜ Prevent overwrite (use UUID or revision path)

âœ… ğŸ“  backend/secrets/net_keys.py

â˜ Fix misleading â€œencrypted-at-restâ€ comment
â˜ Remove unused NET_API_KEY_ENV
â˜ Set file permission chmod 600
â˜ Log corrupted key file instead of silent pass

ğŸŸ¢ PHASE 6 â€” FRONTEND (FINAL STEP)
âœ… ğŸ“ frontend/lib/stream-parser.ts

â˜ Never drop partial chunks
â˜ Flush buffer on stream end
â˜ Handle final chunk without newline

ğŸ“ frontend/lib/job-manager.ts

â˜ Reset abort before new request
â˜ Clear stale job on error
â˜ Ensure only one active job per session

ğŸ“ ChatWindow.tsx

â˜ UI must accept single-token responses
â˜ Remove dependency on min length checks
â˜ Ensure typing indicator stops on stream end




 âœ… ğŸ“ upload.py

  Split pipeline:

  metadata phase

 chunking phase

 âœ… ğŸ“ rag.pipeline

 Add skip_embedding=True

 ğŸ“ ingest.py

Ingest ONLY after metadata confirmation

Retrieval query

Filter by latest revision

Frontend

Metadata popup (already exists âœ…)

Warning modal on duplicate metadata 
Explicit â€œProceed anywayâ€ button





TIER-1 â€” CRITICAL (Backend must not crash)

Goal:

Stop runtime crashes

Stop zombie streams

Fix broken routing

Make chat + abort reliable

Files (fixed in this order)

backend/api/chat.py

backend/api/metadata.py â†’ remove / neutralize

backend/api/update.py

backend/state/abort_signals.py

backend/state/abort_signals (1).py â†’ delete

ğŸŸ  TIER-2 â€” RAG CORRECTNESS

Goal:

Prevent old revision leakage

Fix chunk identity

Fix retrieval consistency

Files

backend/rag/metadata.py

backend/rag/keyword_search.py

backend/rag/ingest.py

backend/rag/pipeline.py

ğŸŸ¡ TIER-3 â€” STATE & MEMORY CONSISTENCY

Goal:

Stop silent corruption

Make behavior predictable

Files

backend/state/job_state.py

backend/memory/redis_memory.py

backend/memory/pg_memory.py

ğŸŸ¢ TIER-4 â€” HARDENING (Optional but recommended)

Goal:

Production safety

Net & storage reliability

Files

backend/api/net.py

backend/secrets/net_keys.py

backend/storage/minio_client.py


Metadata:
Company Document ID âœ… 
Revision Number âœ…
Revision Code âœ…
Validity Status âœ…
PDF Name:
Date of Revisionâœ… 

backend/rag/metadata.py

âœ… backend/rag/chunk.py

âœ… backend/rag/ingest.py

âœ… backend/rag/keyword_search.py

âœ… backend/api/chat.py

retrieve.py
2ï¸âƒ£ upload.py
3ï¸âƒ£ update.py
4ï¸âƒ£ metadata.py
5ï¸âƒ£ chat.py


File	Alignment	Needs Metadata?
metadata.py	ğŸŸ¡ 1 fix needed	âœ… Yes
ingest.py	âœ… Correct	âœ… Yes
keyword_search.py	âœ… Correct	âœ… Yes


pipeline.py still uses old document_id / revision logic

chunk_id is generated but not stored correctly

Add checksum-based PDF skip

Add element cache to prevent reparse

Add ingest verification endpoint

Fix progress bar sync




âœ… FILES YOU MUST CHANGE (AUTHORITATIVE LIST)
ğŸ”´ MUST CHANGE (Core â€“ without this RAG will break)
1ï¸âƒ£ backend/state/job_state.py

Problem:
Job state is RAM-only â†’ lost on reload.

Fix:
Add persistent active-document storage (Redis or Postgres).

Add:

save_active_document(session_id, company_document_id, revision_number)

get_active_document(session_id)

This makes the document survive reloads.

ğŸ“Œ Why this file?

It is the single source of truth for session â†” document binding.

2ï¸âƒ£ backend/api/chat.py

Problem:
If job_state == None, chat silently falls back to non-RAG.

Fix:
Restore document from persistent storage when job_state is missing.

Change required in chat():

job_state = get_job_state(session_id)

if not job_state:
    active_doc = get_active_document(session_id)
    if active_doc:
        job_state = JobState(
            job_id="restored",
            status=STATUS_READY,
            session_id=session_id,
            metadata=active_doc,
        )


ğŸ“Œ Why this file?

This is where RAG is enabled or silently disabled.

3ï¸âƒ£ backend/api/upload.py

Problem:
After commit, nothing persists document ownership.

Fix:
After successful commit, persist active document.

Add after mark_job_ready():

save_active_document(
    session_id=job.session_id,
    company_document_id=final_metadata["company_document_id"],
    revision_number=final_metadata["revision_number"],
)


ğŸ“Œ Why this file?

Upload is where the document becomes â€œactiveâ€.

4ï¸âƒ£ backend/api/update.py

Problem:
Metadata commit succeeds, but document ownership isnâ€™t persisted.

Fix:
Same as upload commit â€” persist active document.

ğŸ“Œ Why this file?

Metadata flow is an alternate commit path.

5ï¸âƒ£ frontend/app/lib/api.ts

Problem (CRITICAL BUG):
You send sessionId as job_id.

updateMetadata({ job_id: sessionId }) // âŒ wrong


Fix:
Store and use the real job_id returned by upload.

updateMetadata({
  job_id: uploadResponse.job_id, // âœ… correct
  metadata: values,
});


ğŸ“Œ Why this file?

Backend metadata update randomly fails without this.

ğŸŸ  SHOULD CHANGE (Strongly recommended â€“ prevents confusion)
6ï¸âƒ£ backend/api/chat.py (UX safety)

Prevent hallucination when no document exists.

Replace:

if not job_state:
    normal chat


With:

if not job_state:
    return StreamingResponse(
        [emit_event(system_message_event("ğŸ“„ No active document. Please upload a PDF."))],
        media_type="text/plain",
    )


ğŸ“Œ Result:

No fake answers

User always knows document state

7ï¸âƒ£ frontend/components/chat/ChatWindow.tsx

Problem:
UI gives no indication whether RAG is active.

Fix:
Display active document info (from debug or API).

Example:

Active document: Basis of Design.pdf (Rev 1)


ğŸ“Œ Why?

Prevents â€œis RAG working?â€ confusion forever.

ğŸŸ¡ OPTIONAL BUT EXCELLENT (Enterprise-grade)
8ï¸âƒ£ backend/memory/pg_memory.py or Redis

Store:

session_id â†’ {
  company_document_id,
  revision_number,
  filename,
  committed_at
}


This allows:

multi-session recovery

audit

analytics

document switching

âœ… SUMMARY TABLE (C